.TH REDIS 2
.SH NAME
redis \- Speak the Redis protocol to a Redis database.
.SH SYNOPSIS
.EX
include "redis.m";
redis := load Redis Redis->PATH;

initmod: fn(s: Sys, d: Dial, b: Bufio, st: String);
connect: fn(addr: string): ref RedisClient;
client: fn(io: ref Iobuf): ref RedisClient;

parsecmd: fn(s: string, qc: int): (list of string, int);
packcmd: fn(cmd: list of string): string;

RStr, RInt, RErr: con iota + 1;

setdebug: fn(state: int);

RedisClient: adt {
	call: fn(c: self ref RedisClient, cmd: list of string): list of (int, string);

	# You probably won't need these:
	sendcmd: fn(c: self ref RedisClient, cmd: list of string): int;
	printresult: fn(c: self ref RedisClient);
	parseresult: fn(c: self ref RedisClient): list of (int, string);

	# Internal:
	io: ref Bufio->Iobuf;
};


.EE

.SH DESCRIPTION
.B Redis
allows you to speak the Redis protocol to a Redis database.

You will probably only need the
.I call()
function after calling 
.I initmod()
to initialize the module and
.I connect()
to dial a server.  If you have your own
.I ref Iobuf
and you you would prefer to manage the connection yourself, you can use
.I client()
to initialize a client with that Iobuf.

.I RedisClient.call()
takes lists of strings representing a command and its arguments, and returns
lists of tuples, each containing a type tag (one of
.I RStr
,
.I RInt
,
or
.I Rerr
) and a string representation of the data.

.I sendcmd()
and
.I parseresult()
are the two halves that
.I call()
is made from.
.I call()
is designed for synchronous/transactional commands, where the client issues a command and the server gives a response.  For things like Pub/Sub and 
.B MONITOR
or
.B SYNC
commands (i.e., cases where you may want to read multiple responses after issuing only one command),
you will have to make calls to
.I parseresult()
after calling either
.I sendcmd()
or
.I call()
.

.SH EXAMPLE
.EX
# The library wants some modules passed in:
redis->initmod(sys, dial, bufio, str);

# The client:
client: ref RedisClient = redis->connect('tcp!localhost!6379');

client->call(c, "SET" :: "X" :: "5" :: nil);
client->call(c, "INCRBY" :: "X" :: "3" :: nil);
# Returns (RInt, "8") :: nil
client->call(c, "HSET" :: "HT" :: "X" :: "five" :: nil);
client->call(c, "HGETALL" :: "HT" :: nil);
# Returns (RStr, "X") :: (RStr, "five") :: nil
client->call(c, "KEYS" :: "*" :: nil);
# Returns (Rstr, "X") :: (Rstr, "HT") :: nil

.EE

.SH SOURCE
.B /appl/lib/redis.b
.B /module/redis.m

.SH SEE ALSO
.IR redis (1)
,
.IR bufio (2)

.SH BUGS
It works on my machine and currently does the right thing so far.  This being a new release, no one else has used it so the usual caveats apply.

Errors are ignored unless generated by the server.  So a missing argument will display the error that the server sends back, but a failure on our part to parse a response from the server is silently ignored.

The interface will probably change.  In particular, it is likely that
.I RedisClient
 will carry errors around so that you can see the errors.
