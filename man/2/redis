.TH REDIS 2
.SH NAME
redis \- Speak the Redis protocol to a Redis database.
.SH SYNOPSIS
.EX
include "redis.m";
redis := load Redis Redis->PATH;

initmod: fn(s: Sys, d: Dial, b: Bufio, st: String);
call: fn(io: ref Iobuf, cmd: list of string):
	list of (int, string);
sendcmd: fn(io: ref Iobuf, cmd: list of string): int;
parseresult: fn(io: ref Iobuf): list of (int, string);
RStr, RInt, RErr: con iota + 1;


.EE

.SH DESCRIPTION
.B Redis
allows you to speak the Redis protocol to a Redis database.

You will probably only need the
.I call()
function after calling 
.I initmod().
.I call()
and the rest of the code will probably change.  It takes lists of strings and
returns lists of tuples, each containing a type tag and a string
representation of the data.

.I sendcmd()
and
.I parseresult()
are the two halves that
.I call()
is made from.
.I call()
is designed for synchronous/transactional commands, where the client issues a command and the server gives a response.  For things like Pub/Sub and 
.B MONITOR
or
.B SYNC
commands (i.e., cases where you may want to read multiple responses after issuing only one command),
you will have to make calls to
.I parseresult()
after calling either
.I sendcmd()
or
.I call()
.

.SH EXAMPLE
.EX
# The library wants some modules passed in:
redis->initmod(sys, dial, bufio, str);

# Do a connection and wrap the data FD in an Iobuf.
# See the source for redis(1) for an example.

redis->call(c, "SET" :: "X" :: "5" :: nil);
redis->call(c, "INCRBY" :: "X" :: "3" :: nil);
# Returns (RInt, "8") :: nil
redis->call(c, "HSET" :: "HT" :: "X" :: "five" :: nil);
redis->call(c, "HGETALL" :: "HT" :: nil);
# Returns (RStr, "X") :: (RStr, "five") :: nil
redis->call(c, "KEYS" :: "*" :: nil);
# Returns (Rstr, "X") :: (Rstr, "HT") :: nil

.EE

.SH SOURCE
.B /appl/lib/redis.b
.B /module/redis.m

.SH SEE ALSO
.IR redis (1)
,
.IR bufio (2)

.SH BUGS
This is alpha software.  It works on my machine and currently does the
right thing, usually.

Errors are ignored unless generated by the server.  So a missing argument will display the error that the server sends back, but a failure on our part to parse a response from the server is silently ignored.

The interface will change.  In particular, it is likely that there will be a
client struct that will carry errors around so that you can see the errors.
There are some other functions the module exports but none of those will
remain in their current form.

Most of the interface is undocumented, because it will change.
